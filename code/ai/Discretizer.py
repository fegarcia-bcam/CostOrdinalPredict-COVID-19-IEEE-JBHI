import warnings

import numpy as np
import pandas as pd

from sklearn.preprocessing import KBinsDiscretizer
from sklearn.compose import ColumnTransformer

import config

FEATS_CATEGOR = config.VARS_CATEGORICAL.keys()

VARS_CONTINUOUS = config.VARS_CONTINUOUS
N_BINS_CONTIN = 10
BINNING_CONTIN = 'quantile'

VARS_ORDINAL = config.VARS_ORDINAL
BINNING_ORDINAL = 'uniform'

N_BINS_BINARY = 2  # obviously :-)
BINNING_BINARY = 'uniform'


class DiscretizerX:

    feat_names = None
    feat_categ = None
    discret_cont = None
    transf_discrete = None

    def __init__(self, feat_names, feat_categ, discret_cont):
        self.feat_names = feat_names
        self.feat_categ = feat_categ
        self.discret_cont = discret_cont
        self.transf_discrete = None

    def fit(self, X_in):
        df_in = pd.DataFrame(data=X_in, columns=self.feat_names)

        transf_discrete = []
        for feat in self.feat_names:
            if feat == config.VAR_CLASSIF:
                # target feature for classification, already discrete by nature
                transf = (feat, 'passthrough', [feat])

            elif feat.endswith(config.MISSING_TAG):
                # generated by the imputer's missing indication, already discrete (binary) by construction
                transf = (feat, 'passthrough', [feat])

            elif any([feat.startswith(f_categ) for f_categ in FEATS_CATEGOR]):
                # generated by the categorical one-hot encoder, already discrete (binary) by construction
                transf = (feat, 'passthrough', [feat])

            elif any([feat.startswith(f_cont) for f_cont in VARS_CONTINUOUS]):  # continuous
                if not self.discret_cont:  # continuous features remain as they are, no discretization
                    transf = (feat, 'passthrough', [feat])
                else:
                    n_bins = N_BINS_CONTIN
                    discret = KBinsDiscretizer(n_bins=n_bins, encode='ordinal', strategy=BINNING_CONTIN)
                    transf = (feat, discret, [feat])

            elif feat in VARS_ORDINAL.keys():  # discrete, non-binary
                n_bins = VARS_ORDINAL[feat]
                discret = KBinsDiscretizer(n_bins=n_bins, encode='ordinal', strategy=BINNING_ORDINAL)
                transf = (feat, discret, [feat])

            else:  # binary
                n_bins = N_BINS_BINARY
                discret = KBinsDiscretizer(n_bins=n_bins, encode='ordinal', strategy=BINNING_BINARY)
                transf = (feat, discret, [feat])

            transf_discrete.append(transf)

        self.transf_discrete = ColumnTransformer(transf_discrete)

        with warnings.catch_warnings():
            warnings.filterwarnings('ignore', category=UserWarning)
            self.transf_discrete.fit(df_in, y=None)

        return self

    def transform(self, X_in):
        df_in = pd.DataFrame(data=X_in, columns=self.feat_names)

        with warnings.catch_warnings():
            warnings.filterwarnings('ignore', category=UserWarning)
            X_out = self.transf_discrete.transform(df_in)

        return X_out

    def fit_transform(self, X_in):
        self.fit(X_in)
        return self.transform(X_in)


class DiscretizerY:

    num_classes = None

    def __init__(self, num_classes=config.NUM_CLASSES):
        self.num_classes = num_classes

    def transform(self, y_in):
        y_out = np.around(y_in)
        y_out[y_out < 0] = 0
        y_out[y_out > (self.num_classes - 1)] = (self.num_classes - 1)

        return y_out.astype('int')
